<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="apple-touch-icon" sizes="180x180" href="/css/graphics/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/css/graphics/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/css/graphics/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
    <title>Dashboard - Where's Religion</title>

    <!-- CSS  -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection" />
    <link href="css/style.css" type="text/css" rel="stylesheet" media="screen,projection" />
    <!--  Scripts-->
    <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
    <script src="js/app.js" defer></script>
    <script src="js/materialize.js"></script>
    <script src="js/init.js" defer></script>
</head>

<body>
    <site-nav></site-nav>
    <div class="section">
        <div class="container">
            <img src="https://user-images.githubusercontent.com/1119165/198061307-bb552387-fcdf-4245-9200-7391e4f2c3f9.png"
                width="400">
        </div>
    </div>
    <site-footer></site-footer>
</body>

<script>
/**
 * TODO
 * The user will select an existing Archtype or generate a new Archtype.
 * This will provide an entity URI, which should be assigned to location.hash
 * All data created in the rest of the app will target the value of the hash. 
 */ 
let entity = location.hash
// All of our notes already target this entity, so this entity is "selected"
// If there is no hash (no entity is selected) the user needs to select one now before they can save.

/**
 * Go over each note in the queue, grab its data, assign to the designated entity and entity descriptor
 */
function selectEntity(event) {
    if(location.hash){
        // If we are selecting a new entity, then the mobile notes need to know about their new target.
        // Loop mobile notes in sessionStorage and update their target
    }
    let entityID = event.target.value
    location.hash = entityID
}

/**
 * Go over each note in the queue, grab its data, assign to the designated entity and entity descriptor
 */
async function submitNotes(event) {
    event.stopPropagation()
    event.preventDefault()
    if (!notes || !notes.value) {
        return
    }
    let user = JSON.parse(localStorage.getItem("wr-user"))
    if (!user || !user["@id"]) {
        alert("You must be logged in to submit")
        localStorage.removeItem("wr-user")
        //localStorage.removeItem("mobile_notes")
        return
    }
    let allNotes = JSON.parse(sessionStorage.getItem("mobile_notes")) ?? []
    for await (const note of allNotes){
        // Turn note into the correct Annotation, check if that Annotation exists
        // If Annotation already exists, update it by adding in the text from this note
        // If not, generate that Annotation for the entity noted in location.hash   
        await assignNote(note)
    }
}

//From the LRDA web app.  Just a stub.  Still TODO
function chooseNote(event, noteID, elem){
    if(elem.classList.contains("selected")){
        elem.classList.remove("selected")
        assignNoteWrapper.classList.add("is-hidden")
        event.target.classList.remove("selected")
        elem.setAttribute("noteid", "")
    }
    else{
        document.querySelectorAll(".selectNote").forEach(e =>{
            e.classList.remove("selected")
        })
        elem.classList.add("selected")
        assignNoteWrapper.classList.remove("is-hidden")
        event.target.classList.add("selected")
        elem.setAttribute("noteid", noteID)
    }
}

// FROM LRDA web app.  Just a stub.  Still TODO.
// Should we be doing this with DEER or something??
async function assignNote(event) {
    let user = JSON.parse(localStorage.getItem("lr-user"))
    //If so, update by adding the text in
    //If not, generate the annotation with this as the initial text. 
    const expID = expChooser.value
    const noteType = noteTypes.value
    const noteElem = document.querySelector("li.selected")
    const noteID = noteElem.getAttribute("noteid")
    const noteText = noteElem.getAttribute("fulltext")
    console.log("Experience that gets note is "+expID)
    console.log("Type of note that it is (the Annotation key name) "+noteType)
    //Check if the experience already has this annotation
    const historyWildcard = {"$exists":true, "$size":0}
    let bodyPropValue = `body.${noteType}.value`
    const queryObj = {
        "type" : "Annotation",
        "target" : expID,
        "__rerum.history.next" : historyWildcard,
    }
    queryObj[bodyPropValue] = {"$exists":true}
    const existingAssertion = await fetch(LR.URLS.QUERY, {
        method: "POST",
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(queryObj)
    })
    .then(response => response.json())
    .catch(err => {return []})
    if(existingAssertion.length){
        let assertionToUpdate = existingAssertion[0]
        assertionToUpdate.body[noteType].value += " "+noteText
        assertionToUpdate.creator = user["@id"]
        await fetch(LR.URLS.UPDATE, {
            method: "PUT",
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(assertionToUpdate)
        })
        .then(resp => {
            if(resp.ok){
                LR.ui.globalFeedbackBlip(null, `Note Assigned`, true)
                LR.utils.removeNote(event, "", noteElem, false)
                assignNoteWrapper.classList.add("is-hidden")
            }
            else{
                alert("Could not assign note.")
            }
        })
        .catch(err => {
            alert("Could not assign note")
            return err
        })
    }
    else{
        let newAssertion = {
            "@context": "http://lived-religion.rerum.io/deer-lr/vocab/context.json",
            "type": "Annotation",
            "target": expID,
            "body": {},
            "creator": user["@id"],
            "motivation": "supplementing",
        }
        newAssertion.body[noteType] = {}
        newAssertion.body[noteType].value = noteText
        await fetch(LR.URLS.CREATE, {
            method: "POST",
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(assertionToUpdate)
        })
        .then(resp => {
            if(resp.ok){
                LR.ui.globalFeedbackBlip(event, `Note Assigned`, true)
                LR.utils.removeNote(null, "", noteElem, false)
                assignNoteWrapper.classList.add("is-hidden")
            }
            else{
                alert("Could not assign note.")
            }
        })
        .catch(err => {
            alert("Could not assign note")
            return err
        })
    }
}

//From LRDA Web App.  Just a stub.  Still TODO.
async function removeNote(event, noteID, noteElem, conf) {
    if(conf){
        if(!confirm("If you really want to remove this note, click OK.")){
            return
        }
    }
    fetch(LR.URLS.DELETE, {
        method: "DELETE",
        mode: "cors",
        body: noteID
    })
    .then(resp => {
        if(resp.ok){
            noteElem.remove()
        }
        else{
            alert("There was an error deleting your note.")
        }
    })
    .catch(err => {
        alert("There was an error deleting your note")
        return err
    })
    const remainingElems = notesInQueue.querySelector("li")
    if(!remainingElems){
        notesInQueue.innerHTML = `<option disabled>Your notes queue is empty!  Have a nice day</option>`
    }
}
</script>

</html>